


## Paster

Paster は文字列のパースから抽象構文木の作成までを行えるパーサコンビネータです。
パースの成功のたびに任意のアクションを行うことができますが、
このアクションにはデフォルトで JSON 形式の出力ができるようになっており、
アプリケーションでは独自の抽象構文木を出力することも、デフォルトの JSON 形式の構文木を出力することもどちらでも選択できます。

## 特殊なパーサ

たとえば、キーワード new は直後が文字列以外のときにキーワードとしてマッチしますが、
これを String オブジェクトで直接パースすることはできません。String オブジェクトは news のような単語の先頭３文字にもマッチするからです。
このような場合は正規表現パーサを使うのがよいでしょう。

## sepBy, sepBy1
sepBy(p, q) コンビネータは、q で区切られた　p をパースし、消費した p すべてを配列にして返します。
たとえば、JavaScript の関数定義で、引数の部分はカンマで区切られた識別子になっていますが、これをパースするには

	sepBy(identifier, ",");

と書くことができます。

## seq, array コンビネータ

    var newExpr = seq(keyword_new, tag("ClassName", identifier), "(", tag("params", params), ")");

このパーサの意味は、『キーワード new、識別子、左括弧、引数、右括弧を順に消費する。識別子を ClassName 、引数を params という名前のプロパティとしてオブジェクトを返す』という意味です。従って、


    new Vector2(10, 20)

という式をパースすると、

    { "ClassName": "Vector2", "params": [10, 20] }

というオブジェクトを意味値として返すでしょう。

seq コンビネータで引数として認められるのは、パーサ(String,RegExp含む)か Tag オブジェクトのどちらかです。
tag オブジェクトでタグ付けされたパーサの値のみがオブジェクトのプロパティとして返されます。
同じ名前のタグが存在する場合はエラーになります。

array コンビネータは seq コンビネータとよく似ていますが、値を配列として返すという点が異なります。
各パーサを処理して、undefined 以外の値になった場合に、それを

# lazy コンビネータ

lazy(f) は、関数 f の返り値のパーサでパースをするパーサを返します（なんのこっちゃ）。
これはどんな時に使われるかというと、再帰的なパーサを作るときに使います。
abababab...a という文字列を互いに再帰的なふたつのパーサでぱーすすることをかんがえます。


var p = array("a", q);
var q = or(eof, array("b", p));






## 特殊なパーサ
パーサジェネレータで作成されたオブジェクト以外にも、パーサとして特別に扱われるオブジェクトがあります。

String
       文字列オブジェクトは、単なる文字列を消費する invisible なパーサとして処理されます。
RegExp      
       正規表現オブジェクトは、その正規表現にマッチする文字列を消費する visible なパーサとして処理されます。
